/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package asmtranslator;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import javax.swing.JTable;
import javax.swing.table.DefaultTableModel;

/**
 *
 * @author 79274
 */
public class AsmTranslatorGUI extends javax.swing.JFrame {

    /**
     * Creates new form AsmTranslatorGUI
     */
    public AsmTranslatorGUI() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        panelMain = new javax.swing.JPanel();
        panelSource = new javax.swing.JPanel();
        panelSourceLabel = new javax.swing.JPanel();
        labelSource = new javax.swing.JLabel();
        panelSourceText = new javax.swing.JPanel();
        jScrollPane1 = new javax.swing.JScrollPane();
        textAreaSource = new javax.swing.JTextArea();
        panelResult = new javax.swing.JPanel();
        panelResultLabel = new javax.swing.JPanel();
        labelResult = new javax.swing.JLabel();
        panelSNT = new javax.swing.JPanel();
        jScrollPane2 = new javax.swing.JScrollPane();
        snt = new javax.swing.JTable();
        panelHexLabel = new javax.swing.JPanel();
        labelHex = new javax.swing.JLabel();
        panelHex = new javax.swing.JPanel();
        jScrollPane3 = new javax.swing.JScrollPane();
        textAreaHex = new javax.swing.JTextArea();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowActivated(java.awt.event.WindowEvent evt) {
                formWindowActivated(evt);
            }
        });

        labelSource.setText("Source:");

        javax.swing.GroupLayout panelSourceLabelLayout = new javax.swing.GroupLayout(panelSourceLabel);
        panelSourceLabel.setLayout(panelSourceLabelLayout);
        panelSourceLabelLayout.setHorizontalGroup(
            panelSourceLabelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(panelSourceLabelLayout.createSequentialGroup()
                .addGap(112, 112, 112)
                .addComponent(labelSource, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addGap(113, 113, 113))
        );
        panelSourceLabelLayout.setVerticalGroup(
            panelSourceLabelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(panelSourceLabelLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(labelSource, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap())
        );

        textAreaSource.setColumns(20);
        textAreaSource.setRows(5);
        textAreaSource.setText(".DATA\n     n    db    5\n     m   db    3\n     t     db    10\n     y    dw    ?\n.CODE\nMOV AL,  2\t\nMOV   BL,   n\nmul    BL\t\t\nmov   cx, AX\t\nmov   AL,  m\nmov   BL,   t\nmul    BL\t\nadd    AX, CX\t\nmov   y,  AX\t\n");
        textAreaSource.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyReleased(java.awt.event.KeyEvent evt) {
                textAreaSourceKeyReleased(evt);
            }
        });
        jScrollPane1.setViewportView(textAreaSource);

        javax.swing.GroupLayout panelSourceTextLayout = new javax.swing.GroupLayout(panelSourceText);
        panelSourceText.setLayout(panelSourceTextLayout);
        panelSourceTextLayout.setHorizontalGroup(
            panelSourceTextLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPane1)
        );
        panelSourceTextLayout.setVerticalGroup(
            panelSourceTextLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 326, Short.MAX_VALUE)
        );

        javax.swing.GroupLayout panelSourceLayout = new javax.swing.GroupLayout(panelSource);
        panelSource.setLayout(panelSourceLayout);
        panelSourceLayout.setHorizontalGroup(
            panelSourceLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(panelSourceLabel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
            .addComponent(panelSourceText, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );
        panelSourceLayout.setVerticalGroup(
            panelSourceLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(panelSourceLayout.createSequentialGroup()
                .addComponent(panelSourceLabel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(panelSourceText, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );

        labelResult.setText("Result:");

        javax.swing.GroupLayout panelResultLabelLayout = new javax.swing.GroupLayout(panelResultLabel);
        panelResultLabel.setLayout(panelResultLabelLayout);
        panelResultLabelLayout.setHorizontalGroup(
            panelResultLabelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(panelResultLabelLayout.createSequentialGroup()
                .addGap(116, 116, 116)
                .addComponent(labelResult, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addGap(114, 114, 114))
        );
        panelResultLabelLayout.setVerticalGroup(
            panelResultLabelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(panelResultLabelLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(labelResult)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        snt.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null}
            },
            new String [] {
                "Name", "CA", "Byte", "Hex"
            }
        ) {
            boolean[] canEdit = new boolean [] {
                false, false, false, false
            };

            public boolean isCellEditable(int rowIndex, int columnIndex) {
                return canEdit [columnIndex];
            }
        });
        jScrollPane2.setViewportView(snt);

        javax.swing.GroupLayout panelSNTLayout = new javax.swing.GroupLayout(panelSNT);
        panelSNT.setLayout(panelSNTLayout);
        panelSNTLayout.setHorizontalGroup(
            panelSNTLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE)
        );
        panelSNTLayout.setVerticalGroup(
            panelSNTLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPane2, javax.swing.GroupLayout.DEFAULT_SIZE, 94, Short.MAX_VALUE)
        );

        labelHex.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        labelHex.setText("Hex:");

        javax.swing.GroupLayout panelHexLabelLayout = new javax.swing.GroupLayout(panelHexLabel);
        panelHexLabel.setLayout(panelHexLabelLayout);
        panelHexLabelLayout.setHorizontalGroup(
            panelHexLabelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(panelHexLabelLayout.createSequentialGroup()
                .addGap(121, 121, 121)
                .addComponent(labelHex, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addGap(123, 123, 123))
        );
        panelHexLabelLayout.setVerticalGroup(
            panelHexLabelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(panelHexLabelLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(labelHex, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap())
        );

        textAreaHex.setColumns(20);
        textAreaHex.setRows(5);
        jScrollPane3.setViewportView(textAreaHex);

        javax.swing.GroupLayout panelHexLayout = new javax.swing.GroupLayout(panelHex);
        panelHex.setLayout(panelHexLayout);
        panelHexLayout.setHorizontalGroup(
            panelHexLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPane3, javax.swing.GroupLayout.DEFAULT_SIZE, 269, Short.MAX_VALUE)
        );
        panelHexLayout.setVerticalGroup(
            panelHexLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPane3)
        );

        javax.swing.GroupLayout panelResultLayout = new javax.swing.GroupLayout(panelResult);
        panelResult.setLayout(panelResultLayout);
        panelResultLayout.setHorizontalGroup(
            panelResultLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(panelResultLabel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
            .addComponent(panelSNT, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
            .addComponent(panelHexLabel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
            .addComponent(panelHex, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
        );
        panelResultLayout.setVerticalGroup(
            panelResultLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(panelResultLayout.createSequentialGroup()
                .addComponent(panelResultLabel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(panelSNT, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(panelHexLabel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(panelHex, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap())
        );

        javax.swing.GroupLayout panelMainLayout = new javax.swing.GroupLayout(panelMain);
        panelMain.setLayout(panelMainLayout);
        panelMainLayout.setHorizontalGroup(
            panelMainLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(panelMainLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(panelSource, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(panelResult, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        panelMainLayout.setVerticalGroup(
            panelMainLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(panelMainLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(panelMainLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(panelResult, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(panelSource, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addContainerGap())
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(panelMain, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(panelMain, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void textAreaSourceKeyReleased(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_textAreaSourceKeyReleased
        updateResults();
    }//GEN-LAST:event_textAreaSourceKeyReleased

    private void formWindowActivated(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_formWindowActivated
        updateResults();
    }//GEN-LAST:event_formWindowActivated

    private boolean updateResults() {
        
        DefaultTableModel jsntModel = (DefaultTableModel)snt.getModel();
        jsntModel.setRowCount(0);
        
        textAreaHex.setText("");

        // CA или AC - Счётчик Адреса - Address Counter
        int addressCounter = 0;
        int addressCounterCodeSegment = 0;

        // SNT stands for Symbolic Name Table. ТСИ - Таблица Символических Имён.
        List<String[]> snt = new ArrayList<>();

        // Hex представление сегмента ".CODE"
        List<String[]> hexCodesOfTheCodeSegment = new ArrayList<>();

        // Определение сегмента файла
        // Принимает значения ".DATA", ".CODE"
        String segment = "";

        // Инициализация статичной таблицы команд - начало
        // Название | Адрес | Байты | Операнд 1 | Операнд 2
        final String[][] commandTable = {
        {"MOV", "01", "4", "REGISTER", "MEMORY"},
        {"MOV", "02", "4", "MEMORY", "REGISTER"},
        {"MOV", "03", "3", "REGISTER", "REGISTER"},
        {"MOV", "04", "3", "REGISTER", "CONSTANT1B"},
        {"MOV", "05", "4", "REGISTER", "CONSTANT2B"},
        {"ADD", "06", "3", "REGISTER", "REGISTER"},
        {"ADD", "07", "3", "REGISTER", "CONSTANT1B"},
        {"ADD", "08", "4", "REGISTER", "CONSTANT2B"},
        {"SUB", "09", "3", "REGISTER", "REGISTER"},
        {"SUB", "0A", "3", "REGISTER", "CONSTANT1B"},
        {"SUB", "0B", "4", "REGISTER", "CONSTANT2B"},
        {"INC", "0C", "2", "REGISTER", ""},
        {"DEC", "0D", "2", "REGISTER", ""},
        {"MUL", "0E", "2", "REGISTER", ""},
        };
        // Инициализация статичной таблицы команд - конец

        // Инициализация статичной таблицы регистров - начало
        final String[][] registerTable = {
        {"AL", "01"},
        {"AH", "02"},
        {"AX", "03"},
        {"BL", "04"},
        {"BH", "05"},
        {"BX", "06"},
        {"CL", "07"},
        {"CH", "08"},
        {"CX", "09"},
        {"DL", "0A"},
        {"DH", "0B"},
        {"DX", "0C"},
        };
        // Инициализация статичной таблицы регистров - конец
        
        for (String line : textAreaSource.getText().split("\\n")) {
            
            // Разделить строку на массив слов. Разделителем выступает " "
            String splittedLine[] = line.split(" ");

            // Уберём пустые элементы из массива
            splittedLine = removeEmptyValuesFromTheArray(splittedLine);

            // Определяем на каком сегменте мы находимся на момент обработки строки
            if (splittedLine[0].equals(".DATA")) {
                segment = ".DATA";
                continue;
            } else if (splittedLine[0].equals(".CODE")) {
                segment = ".CODE";
                continue;
            }

            // СЕГМЕНТ 
            // ОБРАБОТКИ 
            // .DATA
            if (segment.equals(".DATA")) {
                
                // Специализированный массив, который в последствии будет добавлен в список массивов
                // Элементы массива представляют собой:
                // Имя переменной, CA, Байтовый размер, Hex формат (не Нёх)
                String[] sntArrayToAdd = new String[4];

                // Чтобы в sntArrayToAdd не было null
                // Пояснение:
                // случай, если sntArrayToAdd[3] == null:
                // sntArrayToAdd[3] += "hello" //ВЫВОД// sntArrayToAdd[3] == "nullhello"
                // случай, если sntArrayToAdd[3] == "":
                // sntArrayToAdd[3] += "hello" //ВЫВОД// sntArrayToAdd[3] == "hello"
                sntArrayToAdd[3] = "";

                // Обработка имени переменной - начало
                // В общих чертах: пропускаем строку, если переменная с таким названием уже есть в списке
                boolean alreadyHaveThisName = false;
                for (String[] sntItem: snt) {
                    if (sntItem[0].equals(splittedLine[0])) {
                        alreadyHaveThisName = true;
                    }
                }
                // Пропускаем строку
                if (alreadyHaveThisName) continue;
                // А если не пропускаем строку, значит новое имя заносим в массив
                sntArrayToAdd[0] = splittedLine[0];
                // Обработка имени переменной - конец

                // Добавим в массив CA в Hex формате
                sntArrayToAdd[1] = Integer.toHexString(addressCounter);

                // Для определения байтового размера. Для db = 1, dw = 2, ...
                int byteSizeFlag;

                // Определение байтового размера на основе команды - начало
                switch (splittedLine[1]) {
                    case "db":
                        byteSizeFlag = 1;
                        break;
                    case "dw":
                        byteSizeFlag = 2;
                        break;
                    case "dd":
                        byteSizeFlag = 4;
                        break;
                    case "dq":
                        byteSizeFlag = 8;
                        break;
                    default:
                        byteSizeFlag = 0;
                }
                // Определение байтового размера на основе команды - конец

                // Добавим в массив значение байтового размера
                sntArrayToAdd[2] = Integer.toString(byteSizeFlag);

                // Если третье слово в строке это "dup"
                if (splittedLine[2].equals("dup")) {
                    // После "dup" стоит какое-либо число. Например 100 в строке "dup 100(0)"
                    // "dups" будет хранить это число
                    String dups = "";
                    // Определяем какое число стоит после "dup"
                    int incr = 0;
                    while (!(splittedLine[3].charAt(incr) == '(')) {
                        dups += splittedLine[3].charAt(incr++);
                    }
                    incr++;
                    // В скобках после "dup" стоит какое-либо значение. Например 0 в строке "dup 100(0)"
                    // "number" будет хранить это значение
                    String value = "";
                    while (!(splittedLine[3].charAt(incr) == ')')) {
                        value += splittedLine[3].charAt(incr++);
                    }
                    // dups раз переводим nubmer в Hex-представление и dups раз добавляем number в массив
                    for (int increm = 0; increm < Integer.parseInt(dups); increm++) {
                        sntArrayToAdd[3] += toHex(value);
                    }
                    // Подсчитываем CA
                    addressCounter += (byteSizeFlag * Integer.parseInt(dups));
                } 
                // Если третье слово в строке это не "dup"
                else {
                    // Проходим по всем значениям, переводим их в Hex представление и заносим в массив
                    // ДОДЕЛАТЬ: 
                    // рассмотреть случай "Dat1 db 1, 2, 10, 15, , ,"
                    int increment = 2;
                    while (increment < splittedLine.length) {
                        sntArrayToAdd[3] += (toHex(splittedLine[increment])).toUpperCase();
                        increment++;
                    }
                    // Подсчитываем CA
                    addressCounter += (byteSizeFlag * (splittedLine.length - 2));
                }
                
                jsntModel.addRow(new Object[]{sntArrayToAdd[0], sntArrayToAdd[1], sntArrayToAdd[2], sntArrayToAdd[3]});
                
                System.out.println(Arrays.toString(sntArrayToAdd));
                // Добавляем в список массив
                snt.add(sntArrayToAdd);
            } else 
                // СЕГМЕНТ 
                // ОБРАБОТКИ 
                // .CODE
            if (segment.equals(".CODE")) {

                // Уберём из массива строки лишние символы
                for (int i = 0; i < splittedLine.length; i++){
                    splittedLine[i] = splittedLine[i].replaceAll("[,	]", "");
                }

                String command = splittedLine[0];
                String[] hexCodeOfTheLine = new String[3];

                // Проверяем есть ли команда в таблице - начало
                boolean commandIsCorrect = false;

                // commandIndex - индекс в таблице, на котором нашли команду. Её сохраним на будущее
                int commandIndex = 0;

                for (String commandTableItem[] : commandTable) {
                    // Если команда в таблице есть
                    if (commandTableItem[0].equals(command.toUpperCase())) {
                        commandIsCorrect = true;
                        break;
                    }
                    commandIndex++;
                }

                // Если команды в таблице нет
                if (!commandIsCorrect) {
                    // И завершить работу приложения
                    return false;
                }
                // Проверяем есть ли команда в таблице - конец

                // Проверяем какого типа первый операнд:
                // Регистр или память? - начало
                String firstOperand = splittedLine[1];
                String firstOperandHex = "";
                String firstOperandType = "";

                // Пройдёмся по таблице регистров
                for (String registerTableItem[] : registerTable) {
                    // Если имя операнда совпало с каким-либо именем из таблицы регистров
                    if (registerTableItem[0].equals(firstOperand.toUpperCase())) {
                        // Значит теперь наш операнд имеет тип - REGISTER
                        firstOperandType = "REGISTER";
                        // Заодно заберём его код, чтобы ещё раз не приходить
                        firstOperandHex = registerTableItem[1];
                        break;
                    }
                }

                // Если тип операнда не определился после предыдущего цикла
                if (firstOperandType.equals("")) {
                    // Пройдёмся по ТСИ
                    for (String sntItem[] : snt) {
                        // Если имя операнда совпало с каким-либо именем из ТСИ
                        if (sntItem[0].equals(firstOperand)) {
                            // Значит теперь наш операнд имеет тип - MEMORY
                            firstOperandType = "MEMORY";
                            // У операнда оказался маленький код
                            // Попросим его не расстраиваться
                            // И предложим свою помощь:
                            int increm = 4;
                            String zeros = "";
                            while (increm > firstOperand.length()) {
                                zeros += "0";
                                increm--;
                            }
                            // Теперь все равны
                            firstOperandHex = zeros + sntItem[1];
                            break;
                        }
                    }
                }

                // Если операнд оказался не памятью и не регистром
                if (firstOperandType.equals("")) {
                    // И завершить работу приложения
                    return false;
                }
                // Проверяем какого типа первый операнд:
                // Регистр или память? - конец

                // Важно объявить до блока try{}
                String secondOperandType = "";
                String secondOperandHex = "";

                // Второго операнда может не оказаться, поэтому исопльзуем try{}
                try {
                    // Проверяем какого типа второй операнд:
                    // Регистр, память или константа? - начало
                    String secondOperand = splittedLine[2];

                    // Если в имени операнда если только цифры
                    if (isNumeric(secondOperand)) {
                        // Если в имени операнда хранится число меньше 256 и больше -129
                        if (Integer.parseInt(secondOperand) < 256 || Integer.parseInt(secondOperand) > -129) {
                            // То наш операнд может стать однобайтовым
                            secondOperandType = "CONSTANT1B";
                        } else {
                            // в противном случае пусть будет пока что считаться двухбайтовым
                            secondOperandType = "CONSTANT2B";
                        }
                        // Заодно заберём с собой его код
                        secondOperandHex = toHex(secondOperand);
                    }

                    // Операнд не оказался константой?
                    if (secondOperandType.equals("")) {
                        // Тогда пройдёмся по таблице регистров
                        for (String registerTableItem[] : registerTable) {
                            // Если есть совпадение имени операнда с каким-либо именем из таблицы регистров
                            if (registerTableItem[0].equals(secondOperand.toUpperCase())) {
                                // Значит теперь наш операнд имеет тип - REGISTER
                                secondOperandType = "REGISTER";
                                // Заберём код
                                secondOperandHex = registerTableItem[1];
                                break;
                            }
                        }
                    }

                    // Всё ещё непонятно какого он типа?
                    if (secondOperandType.equals("")) {
                        // Тогда пройдёмся по ТСИ
                        for (String sntItem[] : snt) {
                            // Если есть совпадение
                            if (sntItem[0].equals(secondOperand)) {
                                // Значит наш операнд имеет тип - MEMORY
                                secondOperandType = "MEMORY";
                                // Дополним код операнда нулями
                                int increm = 4;
                                String zeros = "";
                                while (increm > secondOperand.length()) {
                                    zeros += "0";
                                    increm--;
                                }
                                secondOperandHex = zeros + sntItem[1];
                                break;
                            }
                        }
                    }

                    // Если операнд оказался не памятью, не регистром и не константой
                    if (secondOperandType.equals("")) {
                        // И завершить работу приложения
                        return false;
                    }

                    // Проверяем какого типа второй операнд:
                    // Регистр, память или константа? - конец
                } catch (Exception e) {}

                // Определение двоичного кода команды - начало
                String binaryCode = "";
                for (int i = commandIndex; i < commandTable.length; i++) {
                    if (commandTable[i][0].equals(command.toUpperCase())) {
                        if (commandTable[i][3].equals(firstOperandType)) {
                            if (commandTable[i][4].equals(secondOperandType)) {
                                binaryCode = commandTable[i][1];
                                // CA здесь меняется
                                addressCounterCodeSegment += Integer.parseInt(commandTable[i][2]);
                                // Проверим CA, вывовывоводив в консоль
                                System.out.println("CA: " + Integer.toHexString(addressCounterCodeSegment));
                                break;
                            }
                        }
                    }
                }
                // Определение двоичного кода команды - конец

                // Соберём результат в кучку - начало
                hexCodeOfTheLine[0] = binaryCode;
                hexCodeOfTheLine[1] = firstOperandHex;
                hexCodeOfTheLine[2] = secondOperandHex;
                // Соберём результат в кучку - конец
                
                textAreaHex.append(hexCodeOfTheLine[0] + " " + hexCodeOfTheLine[1] + " " + hexCodeOfTheLine[2] + "\n");

                // Добавим массив в основную массу
                hexCodesOfTheCodeSegment.add(hexCodeOfTheLine);

            }
        }
        return true;
    }
    
    
    
        // Метод для преобразования строки в массив символов, а далее - в коды этих символов согласно ASCII-таблице
        String stringToHex(String string) {
            char charsFromString[] = string.toCharArray();
            StringBuffer stringBuffer = new StringBuffer();
            for (int i = 0; i < charsFromString.length; i++) {
                String hexString = Integer.toHexString(charsFromString[i]);
                stringBuffer.append(hexString);
            }
            return stringBuffer.toString();
        }
        
        boolean isNumeric(String string) {
            try {
                Integer.parseInt(string);
                return true;
            } catch (NumberFormatException e) {
                return false;
            }
        }
        
        // Метод для преобразования какого-либо значения в Hex представление этого значения.
        // Для строки метод будет использовать значения из ASCII
        // Для "?" метод возвращает "00"
        // Для числа метод будет использовать обычное преобразование
        String toHex(String value) {
            switch (value.charAt(0)) {
                case '\'':
                    value = value.replaceAll("[',]", "");
                    return stringToHex(value);
                case '?':
                    return "00";
                default:
                    value = value.replaceAll("[,]", "");
                    String hexValue = Integer.toHexString(Integer.parseInt(value));
                    if ((hexValue.length() % 2) == 1) {
                        hexValue = "0" + hexValue;
                    }
                    return hexValue;
            }
        }
        
        String[] removeEmptyValuesFromTheArray(String[] array) {
            // Убрать пустые значения из массива строк
            return Arrays.stream(array).filter(value ->
                    value != null && value.length() > 0
            )
            .toArray(size -> new String[size]);
        }
        
        // Метод для вывода ТСИ в консольку
        void printSNT(List<String[]> snt) {
            // Вывод ТСИ в консольку - начало

            // Для более красивого вывода определим максимальную длину среди наименований переменных
            int maxLengthAmongNames = 0;
            for (String[] sntArray: snt) {
                for (int i = 0; i < 3; i++) {
                    if (maxLengthAmongNames < sntArray[0].length()) {
                        maxLengthAmongNames = sntArray[0].length();
                    }
                }
            }

            System.out.format("%" + maxLengthAmongNames + "s", "Name");
            System.out.println("   CA Byte Hex");
            for (String[] sntArray: snt) {
                for (int i = 0; i < 4; i++) {
                    switch (i) {
                        case 0:
                            System.out.format("%-" + maxLengthAmongNames + "s", sntArray[i]);
                            break;
                        case 1:
                            int increm = 4;
                            while (increm > sntArray[i].length()) {
                                System.out.print("0");
                                increm--;
                            }
                            System.out.print(sntArray[i]);
                            break;
                        case 2:
                            System.out.format("%4s", sntArray[i]);
                            break;
                        case 3:
                            System.out.print(sntArray[i]);
                        default:
                            break;
                    }
                    System.out.print(" ");
                }
                System.out.println();
            }
            // Вывод ТСИ в консольку - конец
        }
        
    
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(AsmTranslatorGUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(AsmTranslatorGUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(AsmTranslatorGUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(AsmTranslatorGUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new AsmTranslatorGUI().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JScrollPane jScrollPane3;
    private javax.swing.JLabel labelHex;
    private javax.swing.JLabel labelResult;
    private javax.swing.JLabel labelSource;
    private javax.swing.JPanel panelHex;
    private javax.swing.JPanel panelHexLabel;
    private javax.swing.JPanel panelMain;
    private javax.swing.JPanel panelResult;
    private javax.swing.JPanel panelResultLabel;
    private javax.swing.JPanel panelSNT;
    private javax.swing.JPanel panelSource;
    private javax.swing.JPanel panelSourceLabel;
    private javax.swing.JPanel panelSourceText;
    private javax.swing.JTable snt;
    private javax.swing.JTextArea textAreaHex;
    private javax.swing.JTextArea textAreaSource;
    // End of variables declaration//GEN-END:variables
}
